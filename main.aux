\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\providecommand \oddpage@label [2]{}
\@input{text/7_toc.aux}
\citation{qin2019towards}
\citation{qiu2018real}
\citation{wang2015detecting}
\citation{manzoor2016fast}
\citation{kim2018turboflux,min2021symmetric,sun2022rapidflow,li2024newsp}
\citation{ullmann1976algorithm}
\citation{wei2024gcsm,qiu2024gpu}
\@writefile{toc}{\contentsline {section}{\numberline {1}DCSM: Enabling Inter-Batch Parallelism for Continuous Subgraph Matching on GPU}{1}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Introduction}{1}{subsection.1.1}\protected@file@percent }
\newlabel{sec:Intro}{{1.1}{1}{Introduction}{subsection.1.1}{}}
\newlabel{sec:Intro@cref}{{[subsection][1][1]1.1}{[1][1][]1}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:query}{{1a}{1}{Subfigure 1a}{subfigure.1.1}{}}
\newlabel{fig:query@cref}{{[subfigure][1][1]1a}{[1][1][]1}}
\newlabel{sub@fig:query}{{(a)}{a}{Subfigure 1a\relax }{subfigure.1.1}{}}
\newlabel{fig:g0}{{1b}{1}{Subfigure 1b}{subfigure.1.2}{}}
\newlabel{fig:g0@cref}{{[subfigure][2][1]1b}{[1][1][]1}}
\newlabel{sub@fig:g0}{{(b)}{b}{Subfigure 1b\relax }{subfigure.1.2}{}}
\newlabel{fig:g1}{{1c}{1}{Subfigure 1c}{subfigure.1.3}{}}
\newlabel{fig:g1@cref}{{[subfigure][3][1]1c}{[1][1][]1}}
\newlabel{sub@fig:g1}{{(c)}{c}{Subfigure 1c\relax }{subfigure.1.3}{}}
\newlabel{fig:g1}{{1d}{1}{Subfigure 1d}{subfigure.1.4}{}}
\newlabel{fig:g1@cref}{{[subfigure][4][1]1d}{[1][1][]1}}
\newlabel{sub@fig:g1}{{(d)}{d}{Subfigure 1d\relax }{subfigure.1.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces An example of continuous subgraph matching. $G_{k+1}$ is the data graph after applyting update on $G_{k}$. $Q_{d}$ is the query of "diamond" structure. $abcd$ next to the vertices are the vertex labels.\relax }}{1}{figure.caption.3}\protected@file@percent }
\newlabel{fig:csm}{{1}{1}{An example of continuous subgraph matching. $G_{k+1}$ is the data graph after applyting update on $G_{k}$. $Q_{d}$ is the query of "diamond" structure. $abcd$ next to the vertices are the vertex labels.\relax }{figure.caption.3}{}}
\newlabel{fig:csm@cref}{{[figure][1][]1}{[1][1][]1}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces {Query $Q_{d}$}}}{1}{subfigure.1.1}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces {$t$=$0$: Data graph $G_0$}}}{1}{subfigure.1.2}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(c)}{\ignorespaces {$t$=$3$: Data graph $G_1$}}}{1}{subfigure.1.3}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(d)}{\ignorespaces {$t$=$5$: Data graph $G_2$}}}{1}{subfigure.1.4}\protected@file@percent }
\citation{wei2024gcsm}
\citation{netflow}
\citation{netflow}
\newlabel{fig:rtime}{{2a}{2}{Subfigure 2a}{subfigure.2.1}{}}
\newlabel{fig:rtime@cref}{{[subfigure][1][2]2a}{[1][2][]2}}
\newlabel{sub@fig:rtime}{{(a)}{a}{Subfigure 2a\relax }{subfigure.2.1}{}}
\newlabel{fig:gutil}{{2b}{2}{Subfigure 2b}{subfigure.2.2}{}}
\newlabel{fig:gutil@cref}{{[subfigure][2][2]2b}{[1][2][]2}}
\newlabel{sub@fig:gutil}{{(b)}{b}{Subfigure 2b\relax }{subfigure.2.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Average response time and GPU utilization of GCSM. GCSM-x denotes GCSM processing with batch size x. \textbf  {Query:} Q4 (Figure\nobreakspace  {}\ref {fig:queries}). \textbf  {Graph:} Unlabeled Netflow\nobreakspace  {}\cite  {netflow}.\relax }}{2}{figure.caption.4}\protected@file@percent }
\newlabel{fig:profile}{{2}{2}{Average response time and GPU utilization of GCSM. GCSM-x denotes GCSM processing with batch size x. \textbf {Query:} Q4 (Figure~\ref {fig:queries}). \textbf {Graph:} Unlabeled Netflow~\cite {netflow}.\relax }{figure.caption.4}{}}
\newlabel{fig:profile@cref}{{[figure][2][]2}{[1][2][]2}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces {Response Time}}}{2}{subfigure.2.1}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces {GPU Utilization}}}{2}{subfigure.2.2}\protected@file@percent }
\citation{wei2024gcsm}
\citation{sun2022rapidflow}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Background}{3}{subsection.1.2}\protected@file@percent }
\newlabel{sec:Background}{{1.2}{3}{Background}{subsection.1.2}{}}
\newlabel{sec:Background@cref}{{[subsection][2][1]1.2}{[1][3][]3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.1}A Formal Definition of CSM}{3}{subsubsection.1.2.1}\protected@file@percent }
\newlabel{sec:Preliminaries}{{1.2.1}{3}{A Formal Definition of CSM}{subsubsection.1.2.1}{}}
\newlabel{sec:Preliminaries@cref}{{[subsubsection][1][1,2]1.2.1}{[1][3][]3}}
\citation{wei2024gcsm,qiu2024gpu}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.2}Existing GPU-based CSM systems}{4}{subsubsection.1.2.2}\protected@file@percent }
\newlabel{sec:previous_systems}{{1.2.2}{4}{Existing GPU-based CSM systems}{subsubsection.1.2.2}{}}
\newlabel{sec:previous_systems@cref}{{[subsubsection][2][1,2]1.2.2}{[1][4][]4}}
\citation{wei2024gcsm}
\citation{qiu2024gpu}
\citation{wei2024gcsm}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}Overview of DCSM}{5}{subsection.1.3}\protected@file@percent }
\newlabel{sec:overview}{{1.3}{5}{Overview of DCSM}{subsection.1.3}{}}
\newlabel{sec:overview@cref}{{[subsection][3][1]1.3}{[1][5][]5}}
\citation{wei2024gcsm,qiu2024gpu}
\citation{wei2022stmatch,chen2022efficient}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Overview of DCSM. DCSM consists of three functional modules: Graph Updater (GU), Executor (EX), and Garbage Collector (GC). The edge updates $\Delta e_{k}$ flows through these modules sequentially.\relax }}{6}{figure.caption.5}\protected@file@percent }
\newlabel{fig:dcsm_overview}{{3}{6}{Overview of DCSM. DCSM consists of three functional modules: Graph Updater (GU), Executor (EX), and Garbage Collector (GC). The edge updates $\Delta e_{k}$ flows through these modules sequentially.\relax }{figure.caption.5}{}}
\newlabel{fig:dcsm_overview@cref}{{[figure][3][]3}{[1][5][]6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.4}Graph Updater and Multi-Version Graph}{6}{subsection.1.4}\protected@file@percent }
\newlabel{sec:mvg}{{1.4}{6}{Graph Updater and Multi-Version Graph}{subsection.1.4}{}}
\newlabel{sec:mvg@cref}{{[subsection][4][1]1.4}{[1][6][]6}}
\newlabel{fig:gcsm1}{{4a}{7}{Subfigure 4a}{subfigure.4.1}{}}
\newlabel{fig:gcsm1@cref}{{[subfigure][1][4]4a}{[1][6][]7}}
\newlabel{sub@fig:gcsm1}{{(a)}{a}{Subfigure 4a\relax }{subfigure.4.1}{}}
\newlabel{fig:gcsm2}{{4b}{7}{Subfigure 4b}{subfigure.4.2}{}}
\newlabel{fig:gcsm2@cref}{{[subfigure][2][4]4b}{[1][6][]7}}
\newlabel{sub@fig:gcsm2}{{(b)}{b}{Subfigure 4b\relax }{subfigure.4.2}{}}
\newlabel{fig:dcsm}{{4c}{7}{Subfigure 4c}{subfigure.4.3}{}}
\newlabel{fig:dcsm@cref}{{[subfigure][3][4]4c}{[1][6][]7}}
\newlabel{sub@fig:dcsm}{{(c)}{c}{Subfigure 4c\relax }{subfigure.4.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Comparison between GCSM and DCSM. Eight updates $\Delta e_{1}$ - $\Delta e_{8}$ arrive sequentially. The bar in the figure denotes warp activity along the time axis. Each bar is associated with an update $\Delta e_{k}$, labeled inside the bar. In practice, DCSM uses 5,000-10,000 warps for incremental matching, while only 1-4 warps are assigned for graph updates.\relax }}{7}{figure.caption.6}\protected@file@percent }
\newlabel{fig:dcsm_benefit}{{4}{7}{Comparison between GCSM and DCSM. Eight updates $\Delta e_{1}$ - $\Delta e_{8}$ arrive sequentially. The bar in the figure denotes warp activity along the time axis. Each bar is associated with an update $\Delta e_{k}$, labeled inside the bar. In practice, DCSM uses 5,000-10,000 warps for incremental matching, while only 1-4 warps are assigned for graph updates.\relax }{figure.caption.6}{}}
\newlabel{fig:dcsm_benefit@cref}{{[figure][4][]4}{[1][6][]7}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces {GCSM with batch size $1$.}}}{7}{subfigure.4.1}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces {GCSM with batch size $2$.}}}{7}{subfigure.4.2}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(c)}{\ignorespaces {DCSM with inter-batch parallelism.}}}{7}{subfigure.4.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.4.1}Multi-Version Graph (MVG) Data Structure}{7}{subsubsection.1.4.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces The multi-version graph (MVG) data structure and the procedure for updating it with a batch. The MVG before update represents $G_0$ in Figure\nobreakspace  {}\ref {fig:csm}. The vertex ID indexes the $pSlab$, pointing to a $Slab$. Each row of the $Slab$ corresponds to a neighbor array version, storing its creation time ($ct_{min}$), deletion time ($dt_{max}$), and address ($pNb$). Each column of the neighbor array stores the ID, creation time ($ct$), and deletion time ($dt$) of an edge. We use \textbf  {$v_x$: ($ct$, $dt$]} to denote a neighbor array version of $v_x$. For example, $v_1$ has two neighbor array versions: $v_1$: ($0$, $3$] and $v_1$: ($3$, $m$] where $m$ means infinity.\relax }}{8}{figure.caption.7}\protected@file@percent }
\newlabel{fig:adjlist}{{5}{8}{The multi-version graph (MVG) data structure and the procedure for updating it with a batch. The MVG before update represents $G_0$ in Figure~\ref {fig:csm}. The vertex ID indexes the $pSlab$, pointing to a $Slab$. Each row of the $Slab$ corresponds to a neighbor array version, storing its creation time ($ct_{min}$), deletion time ($dt_{max}$), and address ($pNb$). Each column of the neighbor array stores the ID, creation time ($ct$), and deletion time ($dt$) of an edge. We use \textbf {$v_x$: ($ct$, $dt$]} to denote a neighbor array version of $v_x$. For example, $v_1$ has two neighbor array versions: $v_1$: ($0$, $3$] and $v_1$: ($3$, $m$] where $m$ means infinity.\relax }{figure.caption.7}{}}
\newlabel{fig:adjlist@cref}{{[figure][5][]5}{[1][6][]8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.4.2}Update Procedure}{8}{subsubsection.1.4.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.4.3}Parallel Graph Updater}{9}{subsubsection.1.4.3}\protected@file@percent }
\newlabel{sec:async_gu}{{1.4.3}{9}{Parallel Graph Updater}{subsubsection.1.4.3}{}}
\newlabel{sec:async_gu@cref}{{[subsubsection][3][1,4]1.4.3}{[1][9][]9}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces The process of copying three different-sized arrays in parallel using $8$ threads of a warp. $*v_i$ represents the address of $v_i$'s latest neighbor array version in the MVG.\relax }}{9}{figure.caption.8}\protected@file@percent }
\newlabel{fig:copy}{{6}{9}{The process of copying three different-sized arrays in parallel using $8$ threads of a warp. $*v_i$ represents the address of $v_i$'s latest neighbor array version in the MVG.\relax }{figure.caption.8}{}}
\newlabel{fig:copy@cref}{{[figure][6][]6}{[1][9][]9}}
\citation{ullmann1976algorithm}
\citation{wei2022stmatch,chen2022efficient}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.5}Executor}{10}{subsection.1.5}\protected@file@percent }
\newlabel{sec:ex}{{1.5}{10}{Executor}{subsection.1.5}{}}
\newlabel{sec:ex@cref}{{[subsection][5][1]1.5}{[1][10][]10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.5.1}Correctness Guarantee}{10}{subsubsection.1.5.1}\protected@file@percent }
\newlabel{sec:mvnv}{{1.5.1}{10}{Correctness Guarantee}{subsubsection.1.5.1}{}}
\newlabel{sec:mvnv@cref}{{[subsubsection][1][1,5]1.5.1}{[1][10][]10}}
\newlabel{lemma1}{{1}{11}{}{property.1}{}}
\newlabel{lemma1@cref}{{[property][1][]1}{[1][10][]11}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Visualization of edge $e_k$'s lifetime and visibility across other updates.\relax }}{11}{figure.caption.9}\protected@file@percent }
\newlabel{fig:lifetime}{{7}{11}{Visualization of edge $e_k$'s lifetime and visibility across other updates.\relax }{figure.caption.9}{}}
\newlabel{fig:lifetime@cref}{{[figure][7][]7}{[1][11][]11}}
\newlabel{lemma2}{{2}{11}{}{property.2}{}}
\newlabel{lemma2@cref}{{[property][2][]2}{[1][11][]11}}
\newlabel{lemma3}{{3}{12}{}{property.3}{}}
\newlabel{lemma3@cref}{{[property][3][]3}{[1][12][]12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.5.2}Continuous Subgraph Matching-Specific Optimizations}{12}{subsubsection.1.5.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.6}Garbage Collector}{13}{subsection.1.6}\protected@file@percent }
\newlabel{sec:gc}{{1.6}{13}{Garbage Collector}{subsection.1.6}{}}
\newlabel{sec:gc@cref}{{[subsection][6][1]1.6}{[1][13][]13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.6.1}Release Conditions}{13}{subsubsection.1.6.1}\protected@file@percent }
\newlabel{sec:rc}{{1.6.1}{13}{Release Conditions}{subsubsection.1.6.1}{}}
\newlabel{sec:rc@cref}{{[subsubsection][1][1,6]1.6.1}{[1][13][]13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.6.2}Garbage Collection Graph (GCG)}{14}{subsubsection.1.6.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces A garbage collection graph (GCG) built from the 3 updates $\Delta e_0$, $\Delta e_1$, $\Delta e_2$ in Figure\nobreakspace  {}\ref {fig:adjlist}.\relax }}{14}{figure.caption.10}\protected@file@percent }
\newlabel{fig:aux}{{8}{14}{A garbage collection graph (GCG) built from the 3 updates $\Delta e_0$, $\Delta e_1$, $\Delta e_2$ in Figure~\ref {fig:adjlist}.\relax }{figure.caption.10}{}}
\newlabel{fig:aux@cref}{{[figure][8][]8}{[1][14][]14}}
\newlabel{fig:gc_1}{{9a}{15}{Subfigure 9a}{subfigure.9.1}{}}
\newlabel{fig:gc_1@cref}{{[subfigure][1][9]9a}{[1][15][]15}}
\newlabel{sub@fig:gc_1}{{(a)}{a}{Subfigure 9a\relax }{subfigure.9.1}{}}
\newlabel{fig:gc_2}{{9b}{15}{Subfigure 9b}{subfigure.9.2}{}}
\newlabel{fig:gc_2@cref}{{[subfigure][2][9]9b}{[1][15][]15}}
\newlabel{sub@fig:gc_2}{{(b)}{b}{Subfigure 9b\relax }{subfigure.9.2}{}}
\newlabel{fig:gc_3}{{9c}{15}{Subfigure 9c}{subfigure.9.3}{}}
\newlabel{fig:gc_3@cref}{{[subfigure][3][9]9c}{[1][15][]15}}
\newlabel{sub@fig:gc_3}{{(c)}{c}{Subfigure 9c\relax }{subfigure.9.3}{}}
\newlabel{fig:gc_4}{{9d}{15}{Subfigure 9d}{subfigure.9.4}{}}
\newlabel{fig:gc_4@cref}{{[subfigure][4][9]9d}{[1][15][]15}}
\newlabel{sub@fig:gc_4}{{(d)}{d}{Subfigure 9d\relax }{subfigure.9.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces (a)–(d) illustrate how GC releases neighbor arrays on the GCG in Figure\nobreakspace  {}\ref {fig:aux}. This GCG is stored in an adjacency-list format.\relax }}{15}{figure.caption.11}\protected@file@percent }
\newlabel{fig:gc_step}{{9}{15}{(a)–(d) illustrate how GC releases neighbor arrays on the GCG in Figure~\ref {fig:aux}. This GCG is stored in an adjacency-list format.\relax }{figure.caption.11}{}}
\newlabel{fig:gc_step@cref}{{[figure][9][]9}{[1][15][]15}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces {The incremental matching of $\Delta e_0$ is finished, $v_1$:$(0, 3 ]$ and $v_3$:$(0, 3 ]$ can be released.}}}{15}{subfigure.9.1}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces {The incremental matching of $\Delta e_2$ is finished.}}}{15}{subfigure.9.2}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(c)}{\ignorespaces {The incremental matching of $\Delta e_1$ is finished, $v_5$:$(0, 7 ]$ can be released.}}}{15}{subfigure.9.3}\protected@file@percent }
\@writefile{lof}{\contentsline {subfigure}{\numberline{(d)}{\ignorespaces {A new $\Delta e_3$ = $(v_1, v_4, +)$ is appended to the end of GCG.}}}{15}{subfigure.9.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.6.3}Implementation}{15}{subsubsection.1.6.3}\protected@file@percent }
\bibstyle{plain}
\bibdata{ref.bib}
\bibcite{netflow}{1}
\bibcite{chen2022decomine}{2}
\bibcite{chen2022efficient}{3}
\bibcite{kim2018turboflux}{4}
\bibcite{li2024newsp}{5}
\bibcite{manzoor2016fast}{6}
\bibcite{min2021symmetric}{7}
\bibcite{qin2019towards}{8}
\@writefile{toc}{\contentsline {section}{References}{17}{figure.caption.11}\protected@file@percent }
\bibcite{qiu2024gpu}{9}
\bibcite{qiu2018real}{10}
\bibcite{sun2020rapidmatch}{11}
\bibcite{sun2022rapidflow}{12}
\bibcite{ullmann1976algorithm}{13}
\bibcite{wang2015detecting}{14}
\bibcite{wei2022stmatch}{15}
\bibcite{wei2024gcsm}{16}
\bibcite{yuan2023everest}{17}
\gdef \@abspage@last{23}
